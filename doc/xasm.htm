<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>xasm 2.6.1</title>
<meta name="Author" content="Piotr Fusik"/>
</head>
<body>
<h2>NAME</h2>
<p>xasm - 6502 cross-assembler</p>
<h2>SYNOPSIS</h2>
<p><tt>xasm source [options]</tt></p>
<h2>DESCRIPTION</h2>
<p><b>xasm</b> is a cross-assembler which generates code for the 6502
processor.</p>
<p><tt>source</tt> is the name of the source file. If no filename extension
is given, <tt>.ASX</tt> is appended. The default action (when invoked without
options) is to assembly <tt>source</tt>, writing the result to a file with
the <tt>.OBX</tt> extension.</p>
<h2>OPTIONS</h2>
<dl>
<dt><tt>/c</tt></dt>
<dd>Enable listing false conditionals.
Lines skipped due to a false condition are not listed by default.</dd>
<dt><a name="new_deflabel"/><tt>/d:label=value</tt></dt>
<dd>Define a label.
<tt>label</tt> should be a valid label name.
<tt>value</tt> may be any expression (it may use forward references
to labels defined in the source file).
You may use several <tt>/d</tt> options to define many labels
from the command line.</dd>
<dt><a name="new_environment"/><tt>/e</tt></dt>
<dd>Enable setting environment variables pointing at the error location.
With this option, <b>xasm</b> sets two environment variables:
<tt>ERRFILE</tt> and <tt>ERRLINE</tt>.
They may be used in a batch file to locate the error and set editor's
insertion point on it. If there was no error, the variables point at the last
issued warning. If no warning occured, they are removed from
the environment.</dd>
<dt><tt>/i</tt></dt>
<dd>Disable listing included sources. Only main source file will be
listed.</dd>
<dt><tt>/l[:filename]</tt></dt>
<dd>Enable listing. If no <tt>filename</tt> is given, the listing is written
to <tt>source.lst</tt>, where <tt>source</tt> is the name of the source file
(without the extension).</dd>
<dt><tt>/o:filename</tt></dt>
<dd>Specify object file name. The default is <tt>source.obx</tt>.
You may use the null device (<tt>/o:nul</tt>) to generate no object file.</dd>
<dt><a name="new_fullpaths"/><tt>/p</tt></dt>
<dd>Print fully qualified file names in listing and error messages.
This option is useful for the Code-Genie editor, which can jump to the error
location only if the full path is given.</dd>
<dt><a name="new_quiet"/><tt>/q</tt></dt>
<dd>Suppress info messages.
Prevents <b>xasm</b> from printing its name and the summary (how many lines
assembled and bytes written). Good if you are building a project from many
source files and don't want tons of messages.</dd>
<dt><tt>/t[:filename]</tt></dt>
<dd>List label table. If no <tt>filename</tt> given, the table is appended
to the listing.</dd>
<dt><a name="new_unlabels"/><tt>/u</tt></dt>
<dd>Warn of unused labels. A warning message will be issued for each label,
whose value is never used.</dd>
</dl>
<h2>SYNTAX</h2>
<p>Source files should be plain ASCII files. Although different line
terminators are supported, CR/LF is recommended because it is the standard
in the DOS/Windows environment. Lines must be no longer than 256
characters. <b>xasm</b> is not case-sensitive, so you can mix upper-
and lower-case for labels and instructions.</p>
<p><b>xasm</b> is backward compatible with Quick Assembler.
If you want to assembly QA sources with <b>xasm</b>, simply convert the text
file to CR/LF terminators and replace ATASCII specific characters with their
integer representation. You also have to change all <tt>OPT</tt> directives,
but usually you only need to remove them.</p>
<p>A <i>label</i> is a symbol that represents a 32-bit signed integer.
You can define a label by putting its name at the beginning of a line
(with no spaces before). If you do not use the <tt>EQU</tt> directive,
the label is assigned the current value of the origin counter.</p>
<p>Instructions and directives must be preceded with
whitespace. Note that in <b>xasm</b> you can use instruction and directive
names as label names. For example</p>
<pre>nop
</pre><p>defines a label called <tt>nop</tt>, whereas</p>
<pre> nop
</pre><p>is a 6502 instruction.</p>
<p>Full comment lines must start with a semicolon, a pipe or an asterisk,
with optional label definition and spaces before. Here are examples
of full comment lines:</p>
<pre>; this is a comment
 * so it is
label | and this too
</pre>
<p><a name="new_linerep"/>Lines with instructions (and some directives)
may be <i>repeated</i>. A single line may be assembled several times,
for example:</p>
<pre>:4 asl @
table :32*5 dta 5
</pre>
<p>In lines with instructions or directives, a comment starts after
the instruction/directive has been successfully parsed. That is, <b>xasm</b>
does not require a special character to start a comment. However,
you still can use one, because it is usually required for correct syntax
highlighting in text editors.</p>
<pre> lda foo ; this is a comment
 sta bar so it is
 tax #0  tax requires no operand, so #0 starts a comment
</pre>
<p><a name="new_pairing"/>You may put two instructions on the same line.
In this case they have the same operand. For example:</p>
<pre> eor:sta foo
</pre>
<p>is equivalent to</p>
<pre> eor foo
 sta foo
</pre>
<p>Note that</p>
<pre> lda:tax #0
</pre><p>is allowed (<tt>#0</tt> is a comment for <tt>tax</tt>).</p>
<h2>EXPRESSIONS</h2>
<p>Expressions are numbers combined with operators and brackets.
You should use square brackets, because parentheses are reserved
for the indirect addressing.</p>
<p>Numbers are 32-bit signed integers, in the range of -$7fffffff..$7fffffff.
A number may be:</p>
<ul>
<li>a decimal number, e.g. <tt>-12345</tt></li>
<li>a hexadecimal number, e.g. <tt>$abcd</tt></li>
<li>a binary number, e.g. <tt>%10100101</tt></li>
<li>an ASCII character, e.g. <tt>'a'</tt> or <tt>"a"</tt></li>
<li>the origin counter value: <tt>*</tt></li>
<li>a hardware register, e.g. <tt>^4e</tt></li>
<li><a name="new_opcode"/>an op-code, e.g. <tt>{lda #0}</tt> equals
<tt>$a9</tt></li>
<li><a name="new_linecnt"/>the line repeat counter: <tt>#</tt></li>
</ul>
<p>Abbreviations of Atari hardware registers are provided to save you
the trouble of typing two extra characters (<tt>^4e</tt> vs <tt>$d40e</tt>)
and to ease porting software between Atari 8-bit computers and the Atari 5200
console. These are very similar machines, one of the biggest differences is
different location of hardware registers.</p>
<table>
<tr><th>Syntax</th><th>Chip</th>
<th>Value in the Atari 8-bit<br/>computer mode (<tt>opt g-</tt>)</th>
<th>Value in the Atari 5200<br/>game console mode (<tt>opt g+</tt>)</th>
</tr>
<tr><td><tt>^0x</tt></td><td>GTIA</td>
<td><tt>$D00x</tt></td><td><tt>$C00x</tt></td></tr>
<tr><td><tt>^1x</tt></td><td>GTIA</td>
<td><tt>$D01x</tt></td><td><tt>$C01x</tt></td></tr>
<tr><td><tt>^2x</tt></td><td>POKEY</td>
<td><tt>$D20x</tt></td><td><tt>$E80x</tt></td></tr>
<tr><td><tt>^3x</tt></td><td>PIA</td>
<td><tt>$D30x</tt></td><td>error (there's no PIA chip)</td></tr>
<tr><td><tt>^4x</tt></td><td>ANTIC</td>
<td><tt>$D40x</tt></td><td><tt>$D40x</tt></td></tr>
</table>
<p>An op-code is the single-byte op-code of the instruction inside braces.
The operand of the instruction is discarded and is necessary only for
identifying the addressing mode. The instruction should begin just after
the left brace and the right brace should immediately follow the operand
or the instruction.
<a name="new_op_op"/>You can skip the operand if the addressing mode
is fixed. Examples:
<tt>{lda #}</tt>, <tt>{jsr}</tt>, <tt>{bne}</tt>, <tt>{jmp ()}</tt>,
<tt>{sta a:,x}</tt>.</p>
<p>You can use the line repeat counter (<tt>#</tt>) in the repeated lines.
It counts the iterations starting from zero. Examples:</p>
<pre>:3 dta # ; generates three bytes: 00, 01, 02.
line_lo :192 dta l(screen+40*#)
line_hi :192 dta h(screen+40*#)
dl :59 dta $4f,a(screen+40*#),0,$4f,a(screen+40*#),0
</pre>
<p>The follownig binary operators are supported:</p>
<ul>
<li><tt>+&nbsp;</tt> Addition</li>
<li><tt>-&nbsp;</tt> Subtraction</li>
<li><tt>*&nbsp;</tt> Multiplication</li>
<li><tt>/&nbsp;</tt> Division</li>
<li><tt>%&nbsp;</tt> Remainder</li>
<li><tt>&amp;&nbsp;</tt> Bitwise AND</li>
<li><tt>|&nbsp;</tt> Bitwise OR</li>
<li><tt>^&nbsp;</tt> Bitwise XOR</li>
<li><tt>&lt;&lt;</tt> Arithmetic shift left</li>
<li><tt>&gt;&gt;</tt> Arithmetic shift right</li>
<li><tt>=&nbsp;</tt> Equal</li>
<li><tt>==</tt> Equal (same as <tt>=</tt>)</li>
<li><tt>&lt;&gt;</tt> Not equal</li>
<li><tt>!=</tt> Not equal (same as <tt>&lt;&gt;</tt>)</li>
<li><tt>&lt;&nbsp;</tt> Less than</li>
<li><tt>&gt;&nbsp;</tt> Greater than</li>
<li><tt>&lt;=</tt> Less or equal</li>
<li><tt>&gt;=</tt> Greater or equal</li>
<li><tt>&amp;&amp;</tt> Logical AND</li>
<li><tt>||</tt> Logical OR</li>
</ul>
<p><a name="new_unary"/>The following unary operators are supported:</p>
<ul>
<li><tt>+&nbsp;</tt> Plus (does nothing)</li>
<li><tt>-&nbsp;</tt> Minus (changes the sign)</li>
<li><tt>~&nbsp;</tt> Bitwise NOT (complements all bits)</li>
<li><tt>!&nbsp;</tt> Logical NOT (changes true to false and vice versa)</li>
<li><tt>&lt;&nbsp;</tt> Low (extracts the low byte)</li>
<li><tt>&gt;&nbsp;</tt> High (extracts the high byte)</li>
</ul>
<p>The operator precedence is following:</p>
<table>
<tr><td>first</td><td><tt>[]</tt></td>
<td>(brackets)</td></tr>
<tr><td>    </td><td><tt>+ - ~ &lt; &gt;</tt></td>
<td>(unary)</td></tr>
<tr><td>    </td><td><tt>* / % &amp; &lt;&lt; &gt;&gt;</tt></td>
<td>(binary)</td></tr>
<tr><td>    </td><td><tt>+ - | ^</tt></td>
<td>(binary)</td></tr>
<tr><td>    </td><td><tt>= == &lt;&gt; != &lt; &gt; &lt;= &gt;=</tt></td>
<td>(binary)</td></tr>
<tr><td>    </td><td><tt>!</tt></td>
<td>(unary)</td></tr>
<tr><td>    </td><td><tt>&amp;&amp;</tt></td>
<td>(binary)</td></tr>
<tr><td>last </td><td><tt>||</tt></td>
<td>(binary)</td></tr>
</table>
<p>Note that although the operators are similar to those used in C, C++
and Java, their priorities are different than in these languages.</p>
<p>Compare and logical operators assume that zero is false and a non-zero
is true. They return 1 for true.</p>
<p>While calculating an expression, signed 32-bit arithmetic is used.
When range of 32 bits is exceeded, the '<tt>Arithmetic overflow</tt>' error
is generated.</p>
<h2>DIRECTIVES</h2>
<dl>
<dt><tt><b>EQU</b></tt> - assign a value of an expression to the label</dt>
<dd>Note that a label represents a number, not a text macro.<br/>
Examples:
<pre>five equ 5
here equ *
</pre></dd>
<dt><a name="new_opt"/><tt><b>OPT</b></tt> - set assembly options</dt>
<dd>Five options are available:
<ul>
<li><tt>F</tt> - fill the space between <tt>ORG</tt>s
with <tt>$FF</tt> bytes</li>
<li><tt>G</tt> - Atari 5200 mode for hardware register abbreviations</li>
<li><tt>H</tt> - generate Atari executable headers</li>
<li><tt>L</tt> - generate listing</li>
<li><tt>O</tt> - generate object file</li>
</ul>
You can turn any of these on or off.<br/>
The default (if no <tt>OPT</tt> specified) is <tt>opt f-g-h+l+o+</tt>.<br/>
Examples:
<pre> opt l-     listing off
 opt l+o-   listing on, object file off
 opt f+g+h- useful for Atari 5200 cartridges - raw output format, 5200 hw regs
</pre></dd>
<dt><tt><b>ORG</b></tt> - change value of the origin counter</dt>
<dd>You can set some options applied to the new header (if headers are
enabled):
<ul>
<li><tt>a:</tt> tells <b>xasm</b> to always make a header, even it is
unnecessary, like in <tt>ORG *</tt>.</li>
<li><tt>f:</tt> works same as <tt>a:</tt>, but additionally tells to generate
a <tt>$FF,$FF</tt> prefix before the header. <b>xasm</b> adds it
at the beginning of the file by default, so use this option only if you want
the <tt>$FF</tt>'s somewhere inside.</li>
</ul>
Examples:
<pre> org $600
 org f:$700
table org *+100
</pre>
In the latter example <tt>table</tt> points to 100 bytes
of uninitialized data (label is assigned to <tt>*</tt>
before the <tt>ORG</tt> directive is executed).
<p><a name="new_orgr"/>Starting with version 2.6.0, <b>xasm</b> supports code
that is relocated in the memory at runtime. Let's say you want your code
to be run at the zero page. Typically you can't load it directly into this
place, so you load it at a different address and then move at the runtime.
<b>xasm</b> differentiates between the address that it used
for code generation from the address that is used for generating
Atari executable headers. <tt>org r:</tt> affects only the former one.
Example:</p>
<pre> org $8000
 ldx #code_length-1
 mva:rpl code_loaded,x z:code_zpage,x-
 jmp code_zpage

code_loaded
 org r:$30
code_zpage
 jmp * ; ... or something more sensible
code_length equ *-code_zpage
</pre>
<p>Note that both <tt>*</tt> and label definitions use the counter used
for code generation. There is no direct access to the other counter,
because I think this is not useful. If you really need it, you can
always type something like:</p>
<pre>where_am_i equ *-code_zpage+code_loaded
</pre></dd>
<dt><a name="new_dta"/><tt><b>DTA</b></tt> - define data</dt>
<dd>There are various data types:
<ul>
<li>integers
<ul>
<li>bytes: <tt>b(200)</tt> or simply <tt>200</tt></li>
<li>words: <tt>a(10000)</tt></li>
<li>low bytes of words: <tt>l(511)</tt> defines byte 255</li>
<li>high bytes of words: <tt>h(511)</tt> defines byte 1</li>
</ul>
You may enter many expressions in parentheses and combine different types
of data in a single line, separating things with commas.<br/>
You may also define a sine lookup table. The syntax is:<br/>
<tt>sin(center,amp,size,first,last)</tt><br/>
where:
<ul>
<li><tt>center</tt> is a number which is added to every sine value</li>
<li><tt>amp</tt> is the sine amplitude</li>
<li><tt>size</tt> is the sine period</li>
<li><tt>first,last</tt> define range of values in the table.
They are optional. The default are <tt>0,size-1</tt>.</li>
</ul>
Example: <tt>dta a(sin(0,1000,256,0,63))</tt> defines a table of 64 words
representing a quarter of sine with the amplitude of 1000.</li>
<li>real numbers: <tt>r(-1.23456e12)</tt><br/>
Real numbers are written in the 6-byte Atari Floating-Point format.</li>
<li>text strings
<ul>
<li>ASCII strings: <tt>c'Text'</tt> or <tt>c"Text"</tt></li>
<li>ANTIC strings: <tt>d'Text'</tt> or <tt>d"Text"</tt></li>
</ul>
A character string consists of any of characters surrounded by quotation
marks. Within a string, a single quotation mark character is
represented by two succesive quotation marks.<br/>
Placing a <tt>*</tt> character after a string inverts
the highest bit in every byte of the string.</li>
</ul>
Examples of <tt>DTA</tt>:
<pre>
 dta b(1,2),3,a(1000,-1),l(12345,sin(0,127,256))
 dta d"ANTIC"*,c'It''s a string',$9b
</pre></dd>
<dt><tt><b>ICL</b></tt> - include another source file</dt>
<dd>Specifies another file to be included in the assembly as if the contents
of the referenced file appeared in place of the <tt>ICL</tt> statement.
The included file may contain other <tt>ICL</tt> statements.
The <tt>.ASX</tt> extension is added if none given.<br/>
Examples:
<pre>
 icl 'macros.asx'
 icl 'c:\atari\xasm\fileio'
</pre></dd>
<dt><tt><b>END</b></tt> - end assembling file</dt>
<dd>Remaining part of the file is not assembled. If this statement does
not occur, the assembler stops assembling when it encounters the end
of the file.<br/>
Example:
<pre>
 end
</pre></dd>
<dt><tt><b>INS</b></tt> - insert contents of file</dt>
<dd>Copies every byte of the specified file into the object file and updates
the origin counter, as if these bytes were defined with <tt>DTA</tt>.<br/>
You may specify a range of the inserted file. The syntax is following:
<pre>
 ins 'file'[,offset[,length]]
</pre>
The first byte in a file has the offset of zero.<br/>
If the offset is negative, it is counted from the end of the file.<br/>
Examples:
<pre>
 ins 'picture.raw'
 ins 'file',-256  insert last 256 bytes of file
 ins 'file',10,10 insert bytes 10..19 of file
</pre></dd>
<dt><tt><b>RUN</b></tt> - generate run address</dt>
<dd>An Atari executable program should specify a run address.
A program may be loaded in many areas of the memory and started from any
address.
<pre> run addr
</pre>
is equivalent to:
<pre> org $2e0
 dta a(addr)
</pre>
Example:
<pre> run main
</pre></dd>
<dt><tt><b>INI</b></tt> - generate init address</dt>
<dd>An Atari executable program may have some routines which are executed
during the loading process. There may be many init blocks in one file.<br/>
Example:
<pre> ini showpic
</pre></dd>
<dt><tt><b>ERT</b></tt> - generate an error if an expression is true</dt>
<dd>Examples:
<pre> ert *&gt;$c000
 ert len1&gt;$ff||len2&gt;$ff
</pre></dd>
<dt><a name="new_eli"/><tt><b>IFT</b></tt> - assemble if expression is
true<br/>
<tt><b>ELI</b></tt> - else if<br/>
<tt><b>ELS</b></tt> - else<br/>
<tt><b>EIF</b></tt> - end if</dt>
<dd>With these directives you can construct fragments which
are assembled when a condition is met.
Conditional constructions can be nested.<br/>
Example:
<pre>noscr equ 1
widescr equ 1
 ift noscr
 lda #0
 eli widescr
 lda #$23
 els
 lda #$22
 eif
 sta $22f
</pre>
The above example can be rewritten using the line repeating feature:
<pre>noscr equ 1
widescr equ 1
:noscr lda #0
:!noscr&amp;&amp;widescr lda #$23
:!noscr&amp;&amp;!widescr lda #$22
 sta $22f
</pre></dd>
</dl>
<h2>PSEUDO-COMMANDS</h2>
<p>Pseudo-commands are built-in macros.</p>
<dl>
<dt><tt><b>ADD</b></tt> - addition without carry</dt>
<dd>If you have ever programmed a 6502, you must have noticed that you had
to use a <tt>CLC</tt> before <tt>ADC</tt> for every simple addition.<br/>
<b>xasm</b> can do it for you. <tt>ADD</tt> replaces two instructions:
<tt>CLC</tt> and <tt>ADC</tt>.</dd>
<dt><tt><b>SUB</b></tt> - subtraction</dt>
<dd>It is <tt>SEC</tt> and <tt>SBC</tt>.</dd>
<dt><a name="new_repskip"/><tt><b>RCC, RCS, REQ, RMI, RNE, RPL, RVC,
RVS</b></tt> - conditional repeat</dt>
<dd>These are branches to the previous instruction.
They take no operand, because the branch target
is the address of previously assembled instruction.<br/>
Example:
<pre> ldx #0
 mva:rne $500,x $600,x+
</pre>
The example code copies memory $500-$5ff to $600-$6ff.
Here is the same written with standard 6502 commands only:
<pre> ldx #0
loop lda $500,x
 sta $600,x
 inx
 bne loop
</pre></dd>
<dt><tt><b>SCC, SCS, SEQ, SMI, SNE, SPL, SVC, SVS</b></tt> - conditional
skip</dt>
<dd>These are branches over the next instructions. No operand is required,
because the target is the address of the instruction following
the next instruction.<br/>
Example:
<pre> lda #40
 add:sta $80
 scc:inc $81
</pre>
In the above example the word-sized variable $80 is incremented by 40.</dd>
<dt><tt><b>JCC, JCS, JEQ, JMI, JNE, JPL, JVC, JVS</b></tt> - conditional
jumps</dt>
<dd>These are a kind of 'long' branches. While standard branches
(such as <tt>BNE</tt>) have range of -128..+127, these jumps have range
of all 64 kB.<br/>
Example:
<pre> jne dest
</pre>is equivalent to:
<pre> seq:jmp dest
</pre></dd>
<dt><tt><b>INW</b></tt> - increment word</dt>
<dd>Increments a 16-bit word in the memory.<br/>
Example:
<pre> inw dest
</pre>is equivalent to:
<pre> inc dest
 sne:inc dest+1
</pre></dd>
<dt><tt><b>MVA, MVX, MVY</b></tt> - move byte using accumulator, X or Y</dt>
<dd>Each of these pseudo-commands requires two operands
and substitutes two commands:
<pre> mva source dest = lda source : sta dest
 mvx source dest = ldx source : stx dest
 mvy source dest = ldy source : sty dest
</pre></dd>
<dt><a name="new_mwinde"/><tt><b>MWA, MWX, MWY</b></tt> - move word using
accumulator, X or Y</dt>
<dd>These pseudo-commands require two operands
and are combinations of two <tt>MV*</tt>'s:
one to move the low byte, and the other to move the high byte.<br/>
You can't use indirect nor pseudo addressing mode with <tt>MW*</tt>.
Destination must be an absolute address (optionally indexed).<br/>
When source is also absolute, an <tt>mw* source dest</tt> will be:
<pre> mv* source  dest
 mv* source+1 dest+1
</pre>
When source is an immediate, an <tt>mw* #immed dest</tt> will be:
<pre> mv* &lt;immed dest
 mv* &gt;immed dest+1
</pre>
When <tt>&lt;immed</tt> equals <tt>&gt;immed</tt> and <tt>immed</tt>
is not forward-referenced, <b>xasm</b> uses an optimization:
<pre> mv* &lt;immed dest
 st* dest+1
</pre>
If possible, <tt>MWX</tt> and <tt>MWY</tt> use increment/decrement
commands. E.g. <tt>mwx #1 dest</tt> is assembled as:
<pre> ldx #1
 stx dest
 dex
 stx dest+1
</pre></dd>
</dl>
<h2>ADDRESSING MODES</h2>
<p>All addressing modes are entered in the standard 6502 convention except for
the accumulator addressing mode, which should be marked with
the <tt>@</tt> character (as in Quick Assembler).</p>
<p>There are two extra immediate addressing modes:
<tt>&lt;</tt> and <tt>&gt;</tt>,
which use the low/high byte of a 16-bit word constant.
They are for Quick Assembler compatibility.
You can use traditional <tt>#&lt;</tt> and <tt>#&gt;</tt>.
Note <tt>lda &gt;$ff+5</tt> loads 1 (<tt>&gt;$104</tt>),
while <tt>lda #&gt;$ff+5</tt>
loads 5 (<tt>0+5</tt>) to the accumulator, because the unary operator
<tt>&gt;</tt> has a higher priority than the binary plus.</p>
<p>In absolute addressing modes, <b>xasm</b> examines the expression
and uses zero-page addressing mode if it supposes it's possible.
You may override it with <tt>a:</tt> and <tt>z:</tt> prefixes.</p>
<p>Examples:</p>
<pre>
 nop
 asl @
 lda &gt;$1234	assembles to lda #$12
 lda $100,x
 lda a:0	generates 16-bit address
 jmp ($0a)
 lda ($80),y
</pre>
<p>There are also pseudo addressing modes, which are similar to
pseudo-commands. You may use them just like standard addressing modes
in all 6502 commands and pseudo-commands, except for
<tt>MWA</tt>, <tt>MWX</tt> and <tt>MWY</tt>:</p>
<pre> cmd a,x+   =  cmd a,x   : inx
 cmd a,x-   =  cmd a,x   : dex
 cmd a,y+   =  cmd a,y   : iny
 cmd a,y-   =  cmd a,y   : dey
 cmd (z),y+ =  cmd (z),y : iny
 cmd (z),y- =  cmd (z),y : dey
 cmd (z,0)  =  ldx #0    : cmd (z,x)
 cmd (z),0  =  ldy #0    : cmd (z),y
<a name="new_adrmodes"/> cmd (z),0+ =  ldy #0    : cmd (z),y : iny
 cmd (z),0- =  ldy #0    : cmd (z),y : dey
</pre>
<h2>CHANGES</h2>
<h3>Version 2.6.1 (2005-05-21)</h3>
<ul>
<li>no more "Arithmetic overflow" and "Division by zero" errors when correctly
using forward-referenced labels (bug found by Marcin Lewandowski)</li>
<li>the following now assembles:
<pre> ift 0
foo equ 1
 ift foo
 eif
 eif
</pre>
(bug found by Adrian Matoga)</li>
<li>errors for non-existing <tt>INC @</tt> and <tt>DEC @</tt></li>
<li>negative numbers fixed in the listing</li>
</ul>
<h3>Version 2.6.0 (2005-02-07)</h3>
<ul>
<li>long file names are supported under Windows</li>
<li><a href="#new_orgr">support for code that is relocated at runtime</a></li>
<li><a href="#new_linecnt">line repeat counter</a></li>
<li>label values are now 32-bit, not just 17-bit</li>
<li>command-line options <tt>/n</tt> and <tt>/s</tt> are no longer
supported</li>
<li>fatal I/O errors (such as floppy not ready) no longer print the annoying
'<tt>Abort, Retry, Ignore</tt>' message</li>
</ul>
<h3>Version 2.5.2 (2002-10-03)</h3>
<ul>
<li>version 2.5.1 broke Unix EOLs - fixed</li>
<li>version 2.5.1 omitted all blank/comment/label lines, unless <tt>/c</tt>
was used</li>
</ul>
<h3>Version 2.5.1 (2002-08-21)</h3>
<ul>
<li>fixed assembling sources with Atari EOLs</li>
<li>blank/comment/label lines in false conditionals are now correctly omitted
in listing</li>
</ul>
<h3>Version 2.5 (2002-07-08)</h3>
<ul>
<li>fixed another bug, very similar to the previous one, e.g.
<pre> ift 0
:label nop
 eif
</pre>
reported <tt>Label not defined before</tt> error for the repeat count</li>
<li><a href="#new_opt"><tt>OPT F+</tt> causes <tt>ORG</tt>s to fill the space
between the old and the new location with <tt>$FF</tt>s</a></li>
<li><a href="#new_opt"><tt>OPT G+</tt> enables Atari 5200 mode for hardware
register abbreviations</a></li>
</ul>
<h3>Version 2.4.1 (2002-06-27)</h3>
<ul>
<li>fixed a bug related to label definitions in conditionally skipped code,
e.g.
<pre> ift 0
label
 eif
</pre>
reported <tt>No ORG specified</tt> error for the label definition</li>
</ul>
<h3>Version 2.4 (2002-05-22)</h3>
<ul>
<li>fixed a bug causing incorrect unary operator precedence</li>
<li>fixed wrong label value after a skip pseudo-command</li>
<li>the assembler is .EXE (.COM caused problems with DJGPP make due
to a bug in the DJGPP runtime)</li>
<li>the assembler is not compressed (so it occupies less space in the ZIP)</li>
<li>improved command-line parsing: options may be used before source file
name, tab character is a valid separator, <tt>/</tt> may be used as a directory
separator</li>
<li>error and warning messages are written to stderr, not stdout</li>
<li>added <tt>==</tt> (equals) operator, which is equivalent to
<tt>=</tt>(but is more natural for C/C++/Java programmers)</li>
<li><a href="#new_deflabel">added <tt>/d:label=value</tt> option: define
a label</a></li>
<li><a href="#new_fullpaths">added <tt>/p</tt> option: print full paths
in listing and error messages</a></li>
<li><a href="#new_quiet">added <tt>/q</tt> option: quiet mode</a></li>
<li><a href="#new_unlabels">added <tt>/u</tt> option: warn of unused
labels</a></li>
<li><a href="#new_opt">writing to the object file may be suppressed
with <tt>OPT O-</tt></a></li>
<li><a href="#new_eli">added <tt>ELI</tt> (else if) directive</a></li>
<li><a href="#new_mwinde"><tt>MWX</tt> and <tt>MWY</tt> may use
<tt>INX</tt>/<tt>DEX</tt> and <tt>INY</tt>/<tt>DEY</tt>, respectively,
for generating smaller code</a></li>
</ul>
<h3>Version 2.3 (2002-02-10)</h3>
<ul>
<li>double skip (e.g. <tt>SCC:SNE</tt>) bug fixed</li>
<li>real number two-digit exponent bug fixed</li>
<li>trailing spaces in a listing line are now truncated</li>
<li>label definitions allowed in blank, comment and repeated lines</li>
<li><a href="#new_unary">unary operators</a></li>
<li><a href="#new_dta"><tt>DTA</tt> implied byte mode</a></li>
<li><a href="#new_op_op">operand can be skipped for some op-codes</a></li>
</ul>
<h3>Version 2.2 (1999-09-10)</h3>
<ul>
<li>invalid absolute <tt>CPX</tt> and <tt>CPY</tt> op-codes fixed</li>
<li>fixed: addressing mode not checked for branch commands</li>
<li><tt>ICL</tt> in last line bug fixed</li>
<li><tt>OPT H-H+</tt> bug fixed</li>
<li>first <tt>ORG *</tt> bug fixed</li>
<li>origin setting not required until it is used</li>
<li>Unix ($0a), Macintosh ($0d) and Atari ($9b) EOLs allowed in the source</li>
<li>value of 'true' changed to 1</li>
<li><a href="#new_environment">setting environment variables on error
option</a></li>
<li>assembling only if source newer than object option</li>
<li><a href="#new_opcode">op-code extracting</a></li>
<li><a href="#new_linerep">line repeating</a></li>
<li><a href="#new_pairing">instructions pairing</a></li>
<li><a href="#new_repskip">conditional repeat and skip pseudo commands</a></li>
<li><a href="#new_adrmodes"><tt>(),0+</tt> and <tt>(),0-</tt> pseudo
addressing modes</a></li>
</ul>
<h3>Version 2.0 (1998-11-12)</h3>
<ul>
<li>truncating name of object bug fixed</li>
<li><tt>EQU</tt> and <tt>DTA</tt> forward reference bugs fixed</li>
<li>hex number recognizing bug fixed</li>
<li>now <tt>.OBX</tt> is the default extension for Atari executables</li>
<li>assembling options (switches and <tt>OPT</tt> directive)</li>
<li>listing generation</li>
<li>label table generation</li>
<li>conditional assembly</li>
<li>user errors</li>
<li>warnings</li>
<li>improved headers generation</li>
<li>improved expressions - 19 operators and brackets, 32-bit arithmetic</li>
<li>improved signed numbers</li>
<li>6 new pseudo commands (memory-to-memory move)</li>
<li>8 pseudo addressing modes</li>
<li>indirect conditional jumps</li>
<li>Atari floating-point numbers generation</li>
<li>improved <tt>INS</tt>: inserting specified part of file</li>
</ul>
<h3>Version 1.2 (1998-08-14)</h3>
<ul>
<li>first release</li>
</ul>
<h2>AUTHOR</h2>
<p>Piotr Fusik (<a href="mailto:fox@scene.pl">fox@scene.pl</a>)</p>
<h2>SEE ALSO</h2>
<p><a href="editors.htm">How to configure a text editor for a convenient use
of xasm</a></p>
<p>xasm home page
(<a href="http://xasm.atari.org">http://xasm.atari.org</a>)</p>
</body>
</html>
