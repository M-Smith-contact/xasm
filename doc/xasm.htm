<HTML>
<HEAD>
<TITLE>X-Assembler 2.2 Manual</TITLE>
</HEAD>
<BODY BACKGROUND="6502proc.gif">
<CENTER>
<H1>X-Assembler version 2.2</H1>
by <A HREF="mailto:pfusik@elka.pw.edu.pl">Fox/Taquart</A><P>
</CENTER>

<HR></P><A NAME="intro">
<H2>INTRODUCTION
&nbsp;<A HREF="#usage">USAGE</A>
&nbsp;<A HREF="#syntax">SYNTAX</A>
&nbsp;<A HREF="#faq">FAQ</A>
&nbsp;<A HREF="index.htm">BACK</A>
</H2>
The X-Assembler is an cross-assembler, which generates code for the 6502 processor.
It is 99% compatible with Quick Assembler on 8-bit Atari.
<BR>
<H3>CHANGES</H3>
<H4>Version 2.2</H4>
<UL>
<LI> invalid absolute <TT>CPX</TT> and <TT>CPY</TT> op-codes bug fixed
<LI> branch addressing mode not checking bug fixed
<LI> <TT>ICL</TT> in last line bug fixed
<LI> <TT>OPT H-H+</TT> bug fixed
<LI> first <TT>ORG *</TT> bug fixed
<LI> origin setting not required until not used
<LI> Unix ($0a), Macintosh ($0d) and Atari ($9b) EOLs allowed in source
<LI> value of 'true' changed to 1
<LI> <A HREF="#new_environment">
setting environment variables on error option</A>
<LI> <A HREF="#new_newer">
assembling only if source newer than object option</A>
<LI> <A HREF="#new_opcode">op-code extracting</A>
<LI> <A HREF="#new_linerep">line repeating</A>
<LI> <A HREF="#new_pairing">instructions pairing</A>
<LI> <A HREF="#new_repskip">conditional repeat and skip pseudo commands</A>
<LI> <A HREF="#new_adrmodes">
<TT>(),0+</TT> and <TT>(),0-</TT> pseudo addressing modes</A>
</UL>
<H4>Version 2.0</H4>
<UL>
<LI> truncating name of object bug fixed
<LI> <TT>EQU</TT> and <TT>DTA</TT> forward reference bugs fixed
<LI> hex number recognizing bug fixed
<LI> now <TT>.OBX</TT> is default extension for Atari executables
<LI> assembling options (switches and <TT>OPT</TT> directive)
<LI> listing generation
<LI> label table generation
<LI> conditional assembling
<LI> user errors
<LI> warnings
<LI> improved headers generation
<LI> improved expressions - 19 operators and brackets, 32-bit arithmetic
<LI> improved signed numbers
<LI> 6 new pseudo commands (memory-to-memory move)
<LI> 8 pseudo addressing modes
<LI> indirect conditional jumps
<LI> Atari floating-point numbers generation
<LI> improved <TT>INS</TT>: inserting specified part of file
</UL>
<H4>Version 1.2</H4>
<UL>
<LI> first release
</UL>

<HR></P><A NAME="usage">
<H2><A HREF="#intro">INTRODUCTION</A>
&nbsp;USAGE
&nbsp;<A HREF="#syntax">SYNTAX</A>
&nbsp;<A HREF="#faq">FAQ</A>
&nbsp;<A HREF="index.htm">BACK</A>
</H2>

<H3>System requirements</H3>
<UL>
<LI> a PC compatible computer with 386 or better CPU
<LI> a MS-DOS compatible OS
<LI> a numeric coprocessor for generating sinus tables.
Your CPU probably has a built-in coprocessor.
</UL>
<H3>Creating a source program</H3>
Source file should be plain ASCII file. Although different EOLs are supported,
you would probably prefer CR/LF EOLs because of text editor.<BR>
Single line of source should not be longer than 256 characters.
There is no limitation on the length of the file.<BR>
Source may contain tabulators, which are treated as spaces.<BR>
Assembler is not case-sensitive.
<BR>
<H3>Converting Quick Assembler files</H3>
You must convert Atari text file into PC text file (EOL's from $9b to $0d/$0a),
ATASCII 0-31 and 128-255 characters should be replaced with standard ASCII
characters, using QAsm expressions.<BR>
You also have to change all <TT>OPT</TT> directives,
but usually you needn't them at all.
<BR>
<H3>Assembling a source program</H3>
You run assembler from DOS prompt with following syntax:<BR>
<PRE>XASM source [options]
</PRE><TT>source</TT> is name of source file.
If no extension given, the .ASX is added by default.<P>
Optional options are:
<DL>
<DT><TT>/c</TT>
<DD>Enable listing false conditionals.<BR>
By default lines skipped because of false condition are not listed.<P>
<A NAME="new_environment">
<DT><TT>/e</TT>
<DD>Enable setting environment variables when error occurs.<BR>
With this option, X-Asm sets two environment variables: ERRFILE and ERRLINE.
They may be used in a batch file to locate error and set editor on it.
For example, in my batch file I use such construction:
<PRE>XASM %1 /e
IF NOT ERRORLEVEL 1 GOTO ok
NCE +%ERRLINE% %ERRFILE%
</PRE>
NCE stands for Norton Classic Editor.<P>
If there was no error, variables point at last warning.
If no warning occured, they are removed from the environment.<P>
<DT><TT>/i</TT>
<DD>Disable listing included source.<BR>
Only main source file will be listed.<P>
<DT><TT>/l[:fname]</TT>
<DD>Enable generating listing.
If no <TT>fname</TT> given, listing is written to <TT>source.lst.</TT><P>
<A NAME="new_newer">
<DT><TT>/n</TT>
<DD>Check source and object modification times and assemble only
if source is newer than object file. X-Asm does NOT check included
nor inserted files but only main source, so be careful with this option.<P>
<DT><TT>/o:fname</TT>
<DD>Specify object name. Default is <TT>source.obx</TT>.<P>
<DT><TT>/s</TT>
<DD>Disable converting spaces to tabs in listing.
Using tabs makes listing file shorter.<BR>
Tab stops are assumed to be every 8 characters.<P>
<DT><TT>/t[:fname]</TT>
<DD>List label table.
If no <TT>fname</TT> given, table is written at the end of listing.<P>
</DL>

If source is incorrect, X-Asm stops on first encountered error.<P>

Errorlevels returned by X-Asm:<BR>
3 = bad parameters, assembling not started<BR>
2 = error occured<BR>
1 = warning(s) only<BR>
0 = no errors, no warnings<BR>

<H3>Listing structure</H3>
Line of listing includes:
<UL>
<LI> decimal number of line of source file (if source is different than in
previous listed line, appropriate message line is generated)
<LI> hexadecimal origin
<LI> hexadecimal bytes written to object file<BR>
Listed are also generated headers. A <TT>xxxx-yyyy&gt;</TT> in place of origin
represents generated header: <TT>$xxxx</TT> is the first and <TT>$yyyy</TT>
is the last byte of the block.
A <TT>FFFF&gt;</TT> represents two $ff bytes written as a header prefix.<BR>
A plus sign placed after hex numbers stands for more bytes written to object
in this line, not listed through lack of space.
<LI> remaining part of listing line is a copy of source line
</UL>

<H3>Label table structure</H3>
Line of label table includes:
<UL>
<LI> some label attributes:<BR>
<TT>n</TT> - label defined but not used elsewhere<BR>
<TT>2</TT> - label value known in pass 2 only (label definition uses forward
reference and thus you can't do forward references to that label)
<LI> hexadecimal value of the label
<LI> name of the label
</UL>

<HR></P><A NAME="syntax">
<H2><A HREF="#intro">INTRODUCTION</A>
&nbsp;<A HREF="#usage">USAGE</A>
&nbsp;SYNTAX
&nbsp;<A HREF="#faq">FAQ</A>
&nbsp;<A HREF="index.htm">BACK</A>
</H2>
Lines of source code may be:
<UL>
<LI> empty lines - ignored, of course
<LI> comments - ignored, too
<LI> statements - not ignored :-)
</UL>
Comment lines must have one of the following characters in the FIRST column
of the line: <TT>* ; |</TT>

</P><A NAME="expressions">
<H3>Expressions &nbsp;<A HREF="#statements">Statements</A></H3>
Expressions are numbers combined with operators and brackets.
You should use square brackets, because parentheses are reserved
for 6502 indirect addressing.

<H4>Numbers</H4>
Numbers are 32-bit signed integers, in the range of -$7fffffff..$7fffffff.
A number can be:
<TABLE>
<TR><TD WIDTH=300><UL><LI> a decimal number</TD><TD><TT>-12345</TT></TD></TR>
<TR><TD><UL><LI> a hexadedecimal number</TD><TD><TT>$abcd</TT></TD></TR>
<TR><TD><UL><LI> a binary number</TD><TD><TT>%10100101</TT></TD></TR>
<TR><TD><UL><LI> an ASCII character</TD><TD><TT>'a'</TT> or <TT>"a"</TT></TD></TR>
<TR><TD><UL><LI> an origin counter</TD><TD><TT>*</TT></TD></TR>
<TR><TD><UL><LI> a hardware register</TD><TD><TT>^31</TT></TD></TR>
</UL></TABLE>
<DIV STYLE="MARGIN-LEFT: 54">
An abbreviation of Atari hardware register:<BR>
<TT>^0x</TT> means <TT>$d00x</TT><BR>
<TT>^1x</TT> means <TT>$d01x</TT><BR>
<TT>^2x</TT> means <TT>$d20x</TT><BR>
<TT>^3x</TT> means <TT>$d30x</TT><BR>
<TT>^4x</TT> means <TT>$d40x</TT><BR>
where x is a hexadecimal digit.
</DIV>
<A NAME="new_opcode">
<TABLE>
<TR><TD WIDTH=300><UL><LI> an op-code</TD><TD><TT>{lda #0}</TT></TD></TR>
</UL></TABLE>
<DIV STYLE="MARGIN-LEFT: 54">
Byte op-code of instruction inside braces. Operand is discarded
and is necessary only for identifying addressing mode.
Instruction should begin right after left brace and right brace should
immediately follow the operand or the command in implied addressing mode.
</DIV>
<P>

<H4>Operators</H4>
Currently there are 19 operators:<P>

<TABLE>
<TR><TD><TT>+  </TT></TD><TD>Addition</TD></TR>
<TR><TD><TT>-  </TT></TD><TD>Subtraction</TD></TR>
<TR><TD><TT>*  </TT></TD><TD>Multiplication</TD></TR>
<TR><TD><TT>/  </TT></TD><TD>Division</TD></TR>
<TR><TD><TT>%  </TT></TD><TD>Remainder</TD></TR>
<TR><TD><TT>&  </TT></TD><TD>Bitwise and</TD></TR>
<TR><TD><TT>|  </TT></TD><TD>Bitwise or</TD></TR>
<TR><TD><TT>^  </TT></TD><TD>Bitwise xor</TD></TR>
<TR><TD><TT>&lt;&lt; </TT></TD><TD>Arithmetic shift left</TD></TR>
<TR><TD><TT>&gt;&gt; </TT></TD><TD>Arithmetic shift right</TD></TR>
<TR><TD><TT>=  </TT></TD><TD>Equal</TD></TR>
<TR><TD><TT>&lt;&gt; </TT></TD><TD>Not equal</TD></TR>
<TR><TD><TT>!= </TT></TD><TD>Not equal (same as <TT>&lt;&gt;</TT>)</TD></TR>
<TR><TD><TT>&lt;  </TT></TD><TD>Less than</TD></TR>
<TR><TD><TT>&gt;  </TT></TD><TD>Greater than</TD></TR>
<TR><TD><TT>&lt;= </TT></TD><TD>Less or equal</TD></TR>
<TR><TD><TT>&gt;= </TT></TD><TD>Greater or equal</TD></TR>
<TR><TD><TT>&& </TT></TD><TD>Logical and</TD></TR>
<TR><TD><TT>|| </TT></TD><TD>Logical or</TD></TR>
</TABLE>
<P>
Operator precedence:
<TABLE>
<TR><TD>first</TD><TD><TT>[]</TT></TD></TR>
<TR><TD>     </TD><TD><TT>* / % & &lt;&lt; &gt;&gt;</TT></TD></TR>
<TR><TD>     </TD><TD><TT>+ - | ^</TT></TD></TR>
<TR><TD>     </TD><TD><TT>= &lt;&gt; != &lt; &gt; &lt;= &gt;=</TT></TD></TR>
<TR><TD>     </TD><TD><TT>&&</TT></TD></TR>
<TR><TD>last </TD><TD><TT>||</TT></TD></TR>
</TABLE>
<P>
Compare and logical operators assume that zero is false and non-zero is true.
They return 1 for true.<P>
When calculating expression, 32-bit arithmetic is used. When range of 32 bits
is exceeded, <TT>'Arithmetic overflow'</TT> error is generated.<P>

</P><A NAME="statements">
<H3><A HREF="#expressions">Expressions</A> &nbsp;Statements</H3>
A statement is divided into fields:
<UL>
<LI> <A HREF="#label">label field</A>
<LI> <A HREF="#operation">operation field</A>
<LI> <A HREF="#operand">one or two operand fields</A>
<LI> <A HREF="#comment">comment field</A>
</UL>
There should be at least one space between every two fields
and there can't be any space within a field excluding strings.

</P><A NAME="label"><H4>Label field</H4>
This field is optional. It starts from first character of line, without
any blank characters before. It has two applications:
<UL>
<LI> Defining a label.<BR>
Label is a symbol representing an integer of range -$ffff..$ffff.<BR>
Name of a label can contain letters, digits and underscores (<TT>_</TT>).
Digit can't be label's first character.
Name of a label can be as long as you want and all the characters
are meaningful. In Quick Assembler only 6 leading characters were recognized
and some programs may not compile under X-Asm for this reason.<BR>
Defining a label without using <TT>EQU</TT> makes it equal to current value
of the origin counter.<BR>
Label can't be redefined.<P>
<A NAME="new_linerep">
<LI> Repeating the line.<BR>
Repeating means assembling single line several times as if
there were several identical lines. Note it is not just duplicating
bytes written to object.<BR>
Repeat count, which can be any valid expression, has to be preceded
with a colon.<BR>
Examples:
<PRE>:4 asl @
:2 dta a(*)
</PRE>
In the latter example each <TT>DTA</TT> has different operand value.<BR>
If repeat count equals zero, remaining part of line is not assembled.
This allows conditional assembly on single line to be more compact.
</UL>
You can not define a label in line which you repeat.<P>

<A NAME="new_pairing">
</P><A NAME="operation"><H4>Operation field</H4>
Operation field is the only field which is always required.
You have to put one or more spaces or tab characters between label
and operation field. If no label is defined, line must start with a blank
character. Operation field consists of one or two instructions.
The latter case is called instructions pairing, because a pair
of instructions have shared operand. You separate instructions
with a colon.<BR>
Example:
<PRE> adc:sta $80
</PRE>is equivalent to
<PRE> adc $80
 sta $80
</PRE>
Single instruction always consists of 3 letters. It can be:
<OL TYPE=a>
<LI><I> 6502 command</I><BR>
One of 56 well known processor commands.<BR><BR>

<LI><I> compiler directive</I><BR>
One of the following:<P>
<DL>
<DT><TT><B>EQU</B></TT> - assign a value of expression to the label
<DD>Note that label represents a number, not a text macro.<BR>
Examples:
<PRE>five equ 5
here equ *
</PRE>

<DT><TT><B>OPT</B></TT> - set assembling options
<DD>Currently there are two options: listing generating and headers generating.
You can turn any of these on or off.<BR>
Default (if no <TT>OPT</TT> specified) is <TT>opt l+h+</TT>.<BR>
Examples:
<PRE> opt l-    listing off
 opt h-    headers off
 opt l+h-  listing on, headers off
</PRE>

<DT><TT><B>ORG</B></TT> - set new origin counter
<DD>You can set some options applied to new header (if headers are on):
<UL>
<LI><TT>a:</TT> tells X-Asm to always make a header, even it is unnecessary,
like in <TT>ORG *</TT>.
<LI><TT>f:</TT> works same as <TT>a:</TT>, but additionally tells to generate
a $ff,$ff prefix before header. X-Asm adds it to the first header in file
by default, so use this option only if you want the $ff's somewhere inside.<BR>
</UL>
Examples:
<PRE> org $600
 org f:$700
table org *+100
</PRE>
In the latter example <TT>table</TT> points to 100 bytes
of uninitialized data (note label is assigned to <TT>*</TT>
before <TT>ORG</TT> directive is executed).<P>

<DT><TT><B>DTA</B></TT> - define data
<DD>There are various data types:
<UL>
<LI> numbers
<UL>
<LI> bytes: <TT>b(200)</TT>
<LI> words: <TT>a(10000)</TT>
<LI> low bytes of words: <TT>l(511)</TT> defines byte 255
<LI> high bytes of words: <TT>h(511)</TT> defines byte 1<BR>
You may enter many expressions in parentheses and combine different types
of data in single line, separating things with commas.<BR>
You may also define a sinus table. Syntax is:<BR>
<TT>sin(centre,amp,size,first,last)</TT><BR>
where:
<UL>
<LI> <TT>centre</TT> is a number which is added to every sinus value
<LI> <TT>amp</TT> is the amplitude of sinus
<LI> <TT>size</TT> is the period of sinus
<LI> <TT>first,last</TT> define range of values in the table.
They are optional. Default are <TT>0,size-1</TT>.
</UL>
Example: <TT>dta a(sin(0,1000,256,0,63))</TT> defines table of 64 words
representing a quarter of sinus with amplitude of 1000.<P>
<LI> real numbers: <TT>r(-1.23456e12)</TT><BR>
Real numbers are written in 6-byte Atari Floating-Point format. You can't
combine reals with operators, as you can integers.<P>
</UL>
<LI> text strings
<UL>
<LI> ASCII strings: <TT>c'Text'</TT> or <TT>c"Text"</TT>
<LI> ANTIC strings: <TT>d'Text'</TT> or <TT>d"Text"</TT>
</UL>
A character string consists of any of characters surrounded by quotation
marks. Within a string, a single quotation mark character is
represented by two succesive quotation marks.<BR>
Placing a <TT>*</TT> character after a string inverts
high bit in every byte of string.<P>
</UL>
Examples of <TT>DTA</TT>:
<PRE>
 dta b(2,5),a(1000,-1),l(12345,sin(0,127,256))
 dta d"ANTIC"*,c'It''s a string',b(155)
</PRE>

<DT><TT><B>ICL</B></TT> - include another source file
<DD>Specifies another file to be included in the assembly as if the contests of
the referenced file appeared in place of the <TT>ICL</TT> statement.
The included file may contain other <TT>ICL</TT> statements.
The <TT>.ASX</TT> extension is added if none given.<P>
Examples:
<PRE>
 icl 'macros.asx'
 icl 'c:\atari\xasm\fileio'
</PRE>

<DT><TT><B>END</B></TT> - end assembling file
<DD>Remaining part of the file is not assembled. If this statement does
not occur, assembler stops assembling when encounters end of file.<BR>
Example:
<PRE>
 end
</PRE>

<DT><TT><B>INS</B></TT> - insert contents of file
<DD>Copies every byte of specified file into object file and moves origin
counter, as if these bytes were defined with <TT>DTA</TT>.<BR>
You may specify range of inserted file. Syntax is:
<PRE>
 ins 'file'[,offset[,length]]
</PRE>
First byte in file has offset 0.<BR>
If offset is negative, it is counted from the end of file.<BR>
Examples:
<PRE>
 ins 'picture.raw'
 ins 'file',-256   insert last 256 bytes of file
 ins 'file',10,10  insert bytes 10..19 of file
</PRE>

<DT><TT><B>RUN</B></TT> - generate run address
<DD>The Atari executable program should have run address specified.
A program may be loaded in many areas of memory and started from any address.
<PRE> run addr
</PRE>
is equivalent to:
<PRE> org $2e0
 dta a(addr)
</PRE>
Examples:
<PRE> run start
 run program
</PRE>

<DT><TT><B>INI</B></TT> - generate init address
<DD>The Atari executable program may have some routines which are executed
during loading process. There may be many init blocks in one file.<BR>
Examples:
<PRE> ini init
 ini showpic
</PRE>

<DT><TT><B>ERT</B></TT> - generate error if expression is true
<DD>Examples:
<PRE> ert *&gt;$c000
 ert len1&gt;$ff||len2&gt;$ff
</PRE>

<DT><TT><B>IFT</B></TT> - assemble if expression is true<BR>
<TT><B>ELS</B></TT> - else<BR>
<TT><B>EIF</B></TT> - end if<BR>
<DD>With these directives you can construct fragments which
are assembled when a condition is met.
Conditional constructions can be nested.<BR>
Example:
<PRE>noscr equ 1
 ift noscr
 lda #0
 els
 lda #$22
 eif
 sta $22f
</PRE>
Above example can be rewritten using line repeating feature:
<PRE>noscr equ 1
:noscr<>0 lda #0
:noscr=0 lda #$22
 sta $22f
</PRE>

</DL>
<LI><I> pseudo-command</I><BR>
It is something like built-in macro.
Note that it is not an illegal instruction and works on typical 6502.<P>
<DL>
<DT><TT><B>ADD</B></TT> - addition without carry
<DD>If you ever programmed 6502, you must have noticed that you had
to use a <TT>CLC</TT> before <TT>ADC</TT> for every simple addition.<BR>
X-Asm can do it for you. <TT>ADD</TT> replaces two instructions:
<TT>CLC</TT> and <TT>ADC</TT>.<P>

<DT><TT><B>SUB</B></TT> - subtraction
<DD>It is <TT>SEC</TT> and <TT>SBC</TT>.<P>

<A NAME="new_repskip">
<DT><TT><B>RCC, RCS, REQ, RMI, RNE, RPL, RVC, RVS</B></TT> - conditional repeat
<DD>They are branches to the previous instruction.
They take no operand, because the branch target
is the address of previously assembled instruction.<BR>
Example:
<PRE> ldx #0
 mva:rne $500,x $600,x+
</PRE>
The example code copies memory $500-$5ff to $600-$6ff.
With standard 6502 commands only it would be:
<PRE> ldx #0
loop lda $500,x
 sta $600,x
 inx
 bne loop
</PRE>

<DT><TT><B>SCC, SCS, SEQ, SMI, SNE, SPL, SVC, SVS</B></TT> - conditional skip
<DD>They are branches over the next instructions. No operand is required,
because the target is the address of instruction following
the next instruction.<BR>
Example:
<PRE> lda #40
 add:sta $80
 scc:inc $81
</PRE>
In the above example word variable $80 is incremented by 40.<BR>
Nor conditional repeat nor skip pseudo-commands require operand,
thus they can be paired with any other command.<P>

<DT><TT><B>JCC, JCS, JEQ, JMI, JNE, JPL, JVC, JVS</B></TT> - conditional jumps
<DD>They are a kind of 'long' branches. While standard branches
(<TT>BNE, BEQ</TT>) have range of -128..+127, these jumps have range
of all 64 kB.<BR>
Example:
<PRE> jne dest
</PRE>is equivalent to:
<PRE> seq:jmp dest
</PRE>

<DT><TT><B>INW</B></TT> - increment word
<DD>It is a 16-bit memory increment command.<BR>
Example:
<PRE> inw dest
</PRE>is equivalent to:
<PRE> inc dest
 sne:inc dest+1
</PRE>

<DT><TT><B>MVA, MVX, MVY</B></TT> - move byte using accumulator, X or Y
<DD>Any of these pseudo-commands requires two operands
and substitutes two commands:
<PRE> mva source dest = lda source : sta dest
 mvx source dest = ldx source : stx dest
 mvy source dest = ldy source : sty dest
</PRE>

<DT><TT><B>MWA, MWX, MWY</B></TT> - move word using accumulator, X or Y
<DD>They also require two operands
and are combinations of two <TT>MV*</TT>'s:
one to move low byte, and the other to move high byte.<BR>
You can't use indirect nor pseudo addressing modes with <TT>MW*</TT>.
Destination must be absolute address (indexed or not).<BR>
When source is also absolute, a <TT>MW* SOURCE DEST</TT> will be:
<PRE> mv* source   dest
 mv* source+1 dest+1
</PRE>
When source is immediate, a <TT>MW* #IMMED DEST</TT> will be:
<PRE> mv* &lt;immed dest
 mv* &gt;immed dest+1
</PRE>
When <TT>&lt;immed</TT> equals <TT>&gt;immed</TT> and <TT>immed</TT>
is not forward-referenced, X-Asm uses optimization:
<PRE> mv* &lt;immed dest
 st* dest+1
</PRE>
</DL>
</OL>

</P><A NAME="operand"><H4>Operand</H4>
It depends on the operation field. Some statements don't need any operand,
other need two operands.<P>

6502 commands require operand depending on the addressing mode.
Addressing modes should be entered in standard convention except
the accumulator addressing mode, which should be marked with a
<TT>@</TT> character (as in Quick Assembler).<P>

There are two extra immediate addressing modes:
<TT>&lt;</TT> and <TT>&gt;</TT>,
which use low/high byte of word rather than byte value.<P>

In absolute addressing modes, X-Asm examines expression and uses zero-page
addressing mode if it thinks it is possible to do it. You may override it
with <TT>a:</TT> and <TT>z:</TT> prefixes.<P>

Examples:
<PRE>
 nop
 asl @
 lda &gt;$1234	assembles to lda #$12
 lda $100,x
 lda a:0	generates 16-bit address
 jmp ($0a)
 lda ($80),y
</PRE>

There are also pseudo addressing modes, which are similar to
pseudo-commands. You may use them as standard addressing modes
in all 6502 commands and pseudo-commands excluding
<TT>MWA</TT>, <TT>MWX</TT> and <TT>MWY</TT> only:
<PRE> cmd a,x+    =  cmd a,x   : inx
 cmd a,x-    =  cmd a,x   : dex
 cmd a,y+    =  cmd a,y   : iny
 cmd a,y-    =  cmd a,y   : dey
 cmd (z),y+  =  cmd (z),y : iny
 cmd (z),y-  =  cmd (z),y : dey
 cmd (z,0)   =  ldx #0    : cmd (z,x)
 cmd (z),0   =  ldy #0    : cmd (z),y
<A NAME="new_adrmodes"> cmd (z),0+  =  ldy #0    : cmd (z),y : iny
 cmd (z),0-  =  ldy #0    : cmd (z),y : dey
</PRE>

</P><A NAME="comment"><H4>Comment</H4>
Comment in a statement does not start from any special character
like <TT>;</TT> for example. Comment field is implied when appropriate
number of operands was taken.<P>

<HR></P><A NAME="faq">
<H2><A HREF="#intro">INTRODUCTION</A>
&nbsp;<A HREF="#usage">USAGE</A>
&nbsp;<A HREF="#syntax">SYNTAX</A>
&nbsp;FAQ
&nbsp;<A HREF="index.htm">BACK</A>
</H2>
<UL>
<LI><B>Q:</B> Why does X-Asm ignore <TT>+2</TT> in following line?
<PRE>label equ 1 +2
</PRE>
<B>A:</B> X-Asm treats space as operand terminator. Remaining part of line
is a comment. You should write <TT>1+2</TT> without any spaces.<P>

<LI><B>Q:</B> Why does <TT>lda #&lt;table</TT> not work?<P>
<B>A:</B> <TT>&lt;</TT> and <TT>&gt;</TT> represent addressing modes
rather than LOW and HIGH operators.<BR>
You specify <TT>lda &lt;table</TT>, not <TT>lda #&lt;table</TT>
like in most 6502 assemblers.<P>

<LI><B>Q:</B> What's wrong with <TT>asl a</TT> ?<P>
<B>A:</B> You should use <TT>@</TT> for accumulator addressing mode.<P>

<LI><B>Q:</B> What's wrong in following line?
<PRE>label: lda #0
</PRE>
<B>A:</B> Label definition can not include a colon.<P>

<LI><B>Q:</B> I wrote <TT>end start</TT>, where <TT>start</TT> points
to program beginning, but program seems not to start there. Why?<P>
<B>A:</B> You should have explicit run address specified.
Use <TT>run start</TT> directive. <TT>end</TT> takes no operand.<P>

<LI><B>Q:</B> Why this construction does not work:
<PRE>three equ one+two
two   equ one+one
one   equ 1
</PRE>
while this does:
<PRE>
two   equ one+one
one   equ 1
</PRE>
<B>A:</B> X-Asm reads source twice (in pass 1 and pass 2)
from the beginning until the end.<BR>
This allows forward references, but not too complex.<BR>
Keep in mind that assembler should know all the values in second pass.<P>
Example:
<PRE>two   equ one+one   This value is known in 2nd pass only
one   equ 1         This value is known as early as in 1st pass
</PRE>
These values can be fixed in two passes.<BR>
If you insert following statement as first line:
<PRE>three equ one+two
</PRE>
X-Asm will generate an error because it can't fix
the value of <TT>three</TT> in second pass.<P>

<LI><B>Q:</B> X-Asm displayed single error while assembling my program.
When I fixed it, another error appeared. Why?<P>
<B>A:</B> X-Asm displays only first error.<BR>
When you were assembling for the first time, both errors might exist,
but X-Asm stopped assembling on the first one.<P>

<LI> If you have other questions/problems,
<A HREF=mailto:pfusik@elka.pw.edu.pl>write to me</A>.
</UL>
</BODY>
</HTML>