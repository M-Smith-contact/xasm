<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>xasm 3.0.1</title>
<meta name="Author" content="Piotr Fusik"/>
</head>
<body>
<h2>NAME</h2>
<p>xasm - 6502 cross-assembler</p>
<h2>SYNOPSIS</h2>
<p><tt>xasm source [options]</tt></p>
<h2>DESCRIPTION</h2>
<p><b>xasm</b> is a cross-assembler which generates code for the 6502
processor.</p>
<p><tt>source</tt> is the name of the source file. If no filename extension
is given, <tt>.asx</tt> is appended. The default action (when invoked without
options) is to assembly <tt>source</tt>, writing the result to a file with
the <tt>.obx</tt> extension.</p>
<h2>OPTIONS</h2>
<dl>
<dt><tt>/c</tt></dt>
<dd>List lines skipped due to a false condition.</dd>
<dt><a id="new_deflabel"/><tt>/d:label=value</tt></dt>
<dd>Define a label.
<tt>label</tt> should be a valid label name.
<tt>value</tt> may be any expression (it may use forward references
to labels defined in the source file).
You may use several <tt>/d</tt> options to define many labels
from the command line.</dd>
<dt><tt>/i</tt></dt>
<dd>Do not list included files. Only main source file will be listed.</dd>
<dt><tt>/l[:filename]</tt></dt>
<dd>Generate a listing. If no <tt>filename</tt> is given, the listing is written
to <tt>source.lst</tt>, where <tt>source</tt> is the name of the source file
without the extension.</dd>
<dt><tt>/o:filename</tt></dt>
<dd>Set object file name. The default is <tt>source.obx</tt>.
You may use the null device (<tt>/o:nul</tt>) to generate no object file.</dd>
<dt><a id="new_fullpaths"/><tt>/p</tt></dt>
<dd>Print fully qualified file names in listing and error messages.
This option works only on Windows and is silently ignored on other platforms.</dd>
<dt><a id="new_quiet"/><tt>/q</tt></dt>
<dd>Suppress info messages.
Quiet mode. Prevents <b>xasm</b> from printing the logo and the summary.</dd>
<dt><tt>/t[:filename]</tt></dt>
<dd>List label table. If <tt>filename</tt> is omitted then the table is appended
to the listing.</dd>
<dt><a id="new_unlabels"/><tt>/u</tt></dt>
<dd>Issue a warning message for each label whose value is unused.</dd>
</dl>
<p>Alternatively, you may use Unix-style options, for example:</p>
<pre>xasm -i -d DEBUG=1 -l listing.lst source.asx
</pre>
<h2>SYNTAX</h2>
<p>Source files should be plain ASCII files. LF, CR, CR/LF and Atari line terminators
are supported. Labels and instructions are case-insensitive.</p>
<p><b>xasm</b> is backward compatible with Quick Assembler.
To compile QA sources with <b>xasm</b>, simply replace ATASCII-specific characters
with their integer codes. You also have to change all <tt>OPT</tt> directives,
but usually you can simply remove them.</p>
<p>A <i>label</i> is a symbol that represents a 32-bit signed integer.
You can define a label by putting its name at the beginning of a line
(with no spaces before). Unless you use the <tt>EQU</tt> directive,
the label is assigned the current value of the origin counter.</p>
<p>Instructions and directives must be preceded with some whitespace.
Note that in <b>xasm</b> you can use instruction and directive
names as label names. For example</p>
<pre>nop
</pre><p>defines a label called <tt>nop</tt>, whereas</p>
<pre> nop
</pre><p>is a 6502 instruction.</p>
<p>Full comment lines must start with a semicolon, a pipe or an asterisk,
with optional label definition and spaces before. Here are examples
of full comment lines:</p>
<pre>; this is a comment
 * so it is
label | and this too
</pre>
<p><a id="new_linerep"/>Lines with instructions (and some directives)
may be <i>repeated</i>. A single line may be assembled several times,
for example:</p>
<pre>:4 asl @
table :32*5 dta 5
</pre>
<p>In lines with instructions or directives, a comment starts immediately
after the instruction/directive has been successfully parsed.
That is, <b>xasm</b> does not require a special character to start a comment.</p>
<pre> lda foo ; this is a comment
 sta bar so it is
 tax #0  tax has no operand, therefore #0 starts this comment
</pre>
<p><a id="new_pairing"/>You may put two instructions in one line
so they share the operand. For example:</p>
<pre> eor:sta foo
</pre>
<p>is equivalent to</p>
<pre> eor foo
 sta foo
</pre>
<p>Note that</p>
<pre> lda:tax #0
</pre><p>is allowed because <tt>#0</tt> is treated as a comment for <tt>tax</tt>.</p>
<h2>EXPRESSIONS</h2>
<p>Expressions are numbers combined with operators and brackets.
You should use square brackets, because parentheses are reserved
for 6502 indirect addressing.</p>
<p>Numbers can be expressed as:</p>
<ul>
<li>a 32-bit decimal integer, e.g. <tt>-12345</tt></li>
<li>a 32-bit hexadecimal integer, e.g. <tt>$abcd</tt></li>
<li>a 32-bit binary integer, e.g. <tt>%10100101</tt></li>
<li>an ASCII character, e.g. <tt>'a'</tt> or <tt>"a"</tt></li>
<li>origin counter: <tt>*</tt></li>
<li>a hardware register, e.g. <tt>^4e</tt></li>
<li><a id="new_opcode"/>an op-code, e.g. <tt>{lda #0}</tt> equals
<tt>$a9</tt></li>
<li><a id="new_linecnt"/>the line repeat counter: <tt>#</tt></li>
</ul>
<p>Abbreviations of Atari hardware registers are provided to save you
the trouble of typing two extra characters (<tt>^4e</tt> vs <tt>$d40e</tt>)
and to ease porting software between Atari 8-bit computers and the Atari 5200
console. These are very similar machines, one of the biggest differences is
the location of hardware registers.</p>
<table>
<tr><th>Syntax</th><th>Chip</th>
<th>Value in the Atari 8-bit<br/>computer mode (<tt>opt g-</tt>)</th>
<th>Value in the Atari 5200<br/>game console mode (<tt>opt g+</tt>)</th>
</tr>
<tr><td><tt>^0x</tt></td><td>GTIA</td>
<td><tt>$D00x</tt></td><td><tt>$C00x</tt></td></tr>
<tr><td><tt>^1x</tt></td><td>GTIA</td>
<td><tt>$D01x</tt></td><td><tt>$C01x</tt></td></tr>
<tr><td><tt>^2x</tt></td><td>POKEY</td>
<td><tt>$D20x</tt></td><td><tt>$E80x</tt></td></tr>
<tr><td><tt>^3x</tt></td><td>PIA</td>
<td><tt>$D30x</tt></td><td>error (there's no PIA chip)</td></tr>
<tr><td><tt>^4x</tt></td><td>ANTIC</td>
<td><tt>$D40x</tt></td><td><tt>$D40x</tt></td></tr>
</table>
<p>An op-code is the single-byte op-code of the instruction inside braces.
The operand of the instruction is discarded and is necessary only
to recognize the addressing mode. The instruction should begin right after
the left brace and the right brace should immediately follow the operand
or the instruction.
<a id="new_op_op"/>You can skip the operand if the addressing mode
is fixed. Examples:
<tt>{lda #}</tt>, <tt>{jsr}</tt>, <tt>{bne}</tt>, <tt>{jmp ()}</tt>,
<tt>{sta a:,x}</tt>.</p>
<p>You can use the line repeat counter (<tt>#</tt>) in the repeated lines.
It counts the iterations starting from zero. Examples:</p>
<pre>:3 dta # ; generates three bytes: 0, 1, 2.
line_lo :192 dta l(screen+40*#)
line_hi :192 dta h(screen+40*#)
dl :59 dta $4f,a(screen+40*#),0,$4f,a(screen+40*#),0
</pre>
<p>The follownig binary operators are supported:</p>
<ul>
<li><tt>+&nbsp;</tt> Addition</li>
<li><tt>-&nbsp;</tt> Subtraction</li>
<li><tt>*&nbsp;</tt> Multiplication</li>
<li><tt>/&nbsp;</tt> Division</li>
<li><tt>%&nbsp;</tt> Remainder</li>
<li><tt>&amp;&nbsp;</tt> Bitwise AND</li>
<li><tt>|&nbsp;</tt> Bitwise OR</li>
<li><tt>^&nbsp;</tt> Bitwise XOR</li>
<li><tt>&lt;&lt;</tt> Arithmetic shift left</li>
<li><tt>&gt;&gt;</tt> Arithmetic shift right</li>
<li><tt>=&nbsp;</tt> Equal</li>
<li><tt>==</tt> Equal (same as <tt>=</tt>)</li>
<li><tt>&lt;&gt;</tt> Not equal</li>
<li><tt>!=</tt> Not equal (same as <tt>&lt;&gt;</tt>)</li>
<li><tt>&lt;&nbsp;</tt> Less than</li>
<li><tt>&gt;&nbsp;</tt> Greater than</li>
<li><tt>&lt;=</tt> Less or equal</li>
<li><tt>&gt;=</tt> Greater or equal</li>
<li><tt>&amp;&amp;</tt> Logical AND</li>
<li><tt>||</tt> Logical OR</li>
</ul>
<p><a id="new_unary"/>The following unary operators are supported:</p>
<ul>
<li><tt>+&nbsp;</tt> Plus (does nothing)</li>
<li><tt>-&nbsp;</tt> Minus (changes the sign)</li>
<li><tt>~&nbsp;</tt> Bitwise NOT (complements all bits)</li>
<li><tt>!&nbsp;</tt> Logical NOT (changes true to false and vice versa)</li>
<li><tt>&lt;&nbsp;</tt> Low (extracts the low byte)</li>
<li><tt>&gt;&nbsp;</tt> High (extracts the high byte)</li>
</ul>
<p>The operator precedence is following:</p>
<table>
<tr><td>first</td><td><tt>[]</tt></td>
<td>(brackets)</td></tr>
<tr><td>    </td><td><tt>+ - ~ &lt; &gt;</tt></td>
<td>(unary)</td></tr>
<tr><td>    </td><td><tt>* / % &amp; &lt;&lt; &gt;&gt;</tt></td>
<td>(binary)</td></tr>
<tr><td>    </td><td><tt>+ - | ^</tt></td>
<td>(binary)</td></tr>
<tr><td>    </td><td><tt>= == &lt;&gt; != &lt; &gt; &lt;= &gt;=</tt></td>
<td>(binary)</td></tr>
<tr><td>    </td><td><tt>!</tt></td>
<td>(unary)</td></tr>
<tr><td>    </td><td><tt>&amp;&amp;</tt></td>
<td>(binary)</td></tr>
<tr><td>last </td><td><tt>||</tt></td>
<td>(binary)</td></tr>
</table>
<p>Note that although the operators are similar to those used in C, C++
and Java, their priorities are different than in these languages.</p>
<p>Compare and logical operators assume that zero is false and a non-zero
is true. They return 1 for true.</p>
<p>While calculating an expression, signed 32-bit arithmetic is used.
When range of 32 bits is exceeded, an '<tt>Arithmetic overflow</tt>' error
occurs.</p>
<h2>DIRECTIVES</h2>
<dl>
<dt><tt><b>EQU</b></tt> - assign a value of an expression to the label</dt>
<dd>Examples:
<pre>five equ 5
here equ *
</pre></dd>
<dt><a id="new_opt"/><tt><b>OPT</b></tt> - set assembly options</dt>
<dd>Five options are available:
<ul>
<li><tt>F</tt> - fill the space between <tt>ORG</tt>s
with <tt>$FF</tt></li>
<li><tt>G</tt> - Atari 5200 mode for hardware register abbreviations</li>
<li><tt>H</tt> - generate Atari executable headers</li>
<li><tt>L</tt> - write to the listing</li>
<li><tt>O</tt> - write to the object file</li>
</ul>
You can turn any of these on or off.<br/>
The default (if no <tt>OPT</tt> specified) is <tt>opt f-g-h+l+o+</tt>.<br/>
Examples:
<pre> opt l-     listing off
 opt l+o-   listing on, object file off
 opt f+g+h- useful for Atari 5200 cartridges - raw output format, 5200 hw regs
</pre></dd>
<dt><tt><b>ORG</b></tt> - change value of the origin counter</dt>
<dd>If Atari executable headers are enabled, you can use a prefix:
<ul>
<li><tt>a:</tt> starts a new block even if it is not necessary because
the new address equals the current address.</li>
<li><tt>f:</tt> is same as <tt>a:</tt>, but additionally generates
a <tt>$FF,$FF</tt> prefix before the new header. The prefix is automatically
generated at the beginning of the file.</li>
</ul>
Examples:
<pre> org $600
 org f:$700
table org *+100
</pre>
In the latter example <tt>table</tt> points to 100 bytes
of uninitialized data (label is assigned to <tt>*</tt>
before the <tt>ORG</tt> directive is executed).
<p><a id="new_orgr"/>Starting with version 2.6.0, <b>xasm</b> supports code
that is relocated in the memory at runtime. Let's say you want your code
to be located on the zero page. You can't normally load it directly into this
place, so you load it at a different address and then move in your program.
<tt>org r:</tt> changes the address that it used for code generation
but not the address used for generating Atari executable headers.
Example:</p>
<pre> org $8000
 ldx #code_length-1
 mva:rpl code_loaded,x z:code_zpage,x-
 jmp code_zpage

code_loaded
 org r:$30
code_zpage
 jmp * ; ... or something more sensible
code_length equ *-code_zpage
</pre>
<p>Note that both <tt>*</tt> and label definitions use the counter used
for code generation. There is no direct access to the other counter,
because I think this is not useful. If you really need it, you can
always type something like:</p>
<pre>where_am_i equ *-code_zpage+code_loaded
</pre></dd>
<dt><a id="new_dta"/><tt><b>DTA</b></tt> - define data</dt>
<dd>
<ul>
<li>integers
<ul>
<li>bytes: <tt>b(200)</tt> or simply <tt>200</tt></li>
<li>words: <tt>a(10000)</tt></li>
<li>low bytes of words: <tt>l(511)</tt> defines byte 255</li>
<li>high bytes of words: <tt>h(511)</tt> defines byte 1</li>
</ul>
You may enter many expressions in parentheses and combine different types
of data in a single line, separating things with commas.<br/>
You may also define a sine lookup table. The syntax is:<br/>
<tt>sin(center,amp,size,first,last)</tt><br/>
where:
<ul>
<li><tt>center</tt> is a number which is added to every sine value</li>
<li><tt>amp</tt> is the sine amplitude</li>
<li><tt>size</tt> is the sine period</li>
<li><tt>first,last</tt> define the range of sine arguments.
They are optional. The default are <tt>0,size-1</tt>.</li>
</ul>
Example: <tt>dta a(sin(0,1000,256,0,63))</tt> defines a table of 64 words
representing a quarter of sine with the amplitude of 1000.</li>
<li>real numbers: <tt>r(-1.23456e12)</tt><br/>
Real numbers are stored in the 6-byte Atari Floating-Point format.</li>
<li>text strings
<ul>
<li>ASCII strings: <tt>c'Text'</tt> or <tt>c"Text"</tt></li>
<li>ANTIC strings: <tt>d'Text'</tt> or <tt>d"Text"</tt></li>
</ul>
A character string consists of any of characters surrounded by quotation
marks. You can include the quotation marks in the string by doubling them.<br/>
Placing a <tt>*</tt> character after a string inverts
the highest bit in every byte of the string.</li>
</ul>
Examples of <tt>DTA</tt>:
<pre>
 dta b(1,2),3,a(1000,-1),l(12345,sin(0,127,256))
 dta d"ANTIC"*,c'It''s a string',$9b
</pre></dd>
<dt><tt><b>ICL</b></tt> - include another source file</dt>
<dd>Specifies another file to be included in the assembly as if the contents
of the referenced file appeared in place of the <tt>ICL</tt> statement.
The included file may contain other <tt>ICL</tt> statements.
The <tt>.asx</tt> extension is added if none given.<br/>
Examples:
<pre>
 icl 'macros.asx'
 icl 'lib/fileio'
</pre>
Note: for portability, you should use only relative paths and slash
as the separator. This assures that your sources will compile under Windows
and Linux.</dd>
<dt><tt><b>END</b></tt> - end assembling file</dt>
<dd>Remaining part of the file is not assembled. If this statement does
not occur, the assembler stops assembling when it encounters the end
of the file.<br/>
Example:
<pre>
 end
</pre></dd>
<dt><tt><b>INS</b></tt> - insert contents of file</dt>
<dd>Copies every byte of the specified file into the object file and updates
the origin counter, as if these bytes were defined with <tt>DTA</tt>.<br/>
You may specify a range of the file to insert. The syntax is:
<pre>
 ins 'file'[,offset[,length]]
</pre>
The first byte in a file has the offset of zero.<br/>
If the offset is negative, it counts from the end of the file.<br/>
Examples:
<pre>
 ins 'picture.raw'
 ins 'file',-256  insert last 256 bytes of file
 ins 'file',10,10 insert bytes 10..19 of file
</pre></dd>
<dt><tt><b>RUN</b></tt> - set run address in the Atari executable format</dt>
<dd><pre> run addr
</pre>
is equivalent to:
<pre> org $2e0
 dta a(addr)
</pre>
Example:
<pre> run main
</pre></dd>
<dt><tt><b>INI</b></tt> - set init address in the Atari executable format</dt>
<dd>Example:
<pre> ini showpic
</pre></dd>
<dt><tt><b>ERT</b></tt> - generate error if expression evaluates to true</dt>
<dd>Examples:
<pre> ert *&gt;$c000
 ert len1&gt;$ff||len2&gt;$ff
</pre></dd>
<dt><a id="new_eli"/><tt><b>IFT</b></tt> - assemble if expression is
true<br/>
<tt><b>ELI</b></tt> - else if<br/>
<tt><b>ELS</b></tt> - else<br/>
<tt><b>EIF</b></tt> - end if</dt>
<dd>With these directives you can construct fragments which
are assembled when a condition is met.
Conditional constructions can be nested.<br/>
Example:
<pre>noscr equ 1
widescr equ 1
 ift noscr
 lda #0
 eli widescr
 lda #$23
 els
 lda #$22
 eif
 sta $22f
</pre>
The above example can be rewritten using the line repeating feature:
<pre>noscr equ 1
widescr equ 1
:noscr lda #0
:!noscr&amp;&amp;widescr lda #$23
:!noscr&amp;&amp;!widescr lda #$22
 sta $22f
</pre></dd>
</dl>
<h2>PSEUDO-COMMANDS</h2>
<p>Pseudo-commands are built-in macros.</p>
<dl>
<dt><tt><b>ADD</b></tt> - addition without carry</dt>
<dd>If you have ever programmed a 6502, you must have noticed that you had
to use a <tt>CLC</tt> before <tt>ADC</tt> for every simple addition.<br/>
<b>xasm</b> can do it for you. <tt>ADD</tt> replaces two instructions:
<tt>CLC</tt> and <tt>ADC</tt>.</dd>
<dt><tt><b>SUB</b></tt> - subtraction</dt>
<dd>It is <tt>SEC</tt> and <tt>SBC</tt>.</dd>
<dt><a id="new_repskip"/><tt><b>RCC, RCS, REQ, RMI, RNE, RPL, RVC,
RVS</b></tt> - conditional repeat</dt>
<dd>These are branches to the previous instruction.
They take no operand, because the branch target
is the address of the previously assembled instruction.<br/>
Example:
<pre> ldx #0
 mva:rne $500,x $600,x+
</pre>
The example code copies memory $500-$5ff to $600-$6ff.
Here is the same written with standard 6502 commands only:
<pre> ldx #0
loop lda $500,x
 sta $600,x
 inx
 bne loop
</pre></dd>
<dt><tt><b>SCC, SCS, SEQ, SMI, SNE, SPL, SVC, SVS</b></tt> - conditional
skip</dt>
<dd>These are branches over the next instructions. No operand is required,
because the target is the address of the instruction following
the next instruction.<br/>
Example:
<pre> lda #40
 add:sta $80
 scc:inc $81
</pre>
In the above example the word-sized variable $80 is incremented by 40.</dd>
<dt><tt><b>JCC, JCS, JEQ, JMI, JNE, JPL, JVC, JVS</b></tt> - conditional
jumps</dt>
<dd>These are a kind of 'long' branches. While standard branches
(such as <tt>BNE</tt>) have range of -128..+127, these jumps have range
of 64 kB.<br/>
Example:
<pre> jne dest
</pre>is equivalent to:
<pre> seq:jmp dest
</pre></dd>
<dt><tt><b>INW</b></tt> - increment word</dt>
<dd>Increments a 16-bit word in the memory.<br/>
Example:
<pre> inw dest
</pre>is equivalent to:
<pre> inc dest
 sne:inc dest+1
</pre></dd>
<dt><tt><b>MVA, MVX, MVY</b></tt> - move byte using accumulator, X or Y</dt>
<dd>Each of these pseudo-commands requires two operands
and substitutes two commands:
<pre> mva source dest = lda source : sta dest
 mvx source dest = ldx source : stx dest
 mvy source dest = ldy source : sty dest
</pre></dd>
<dt><a id="new_mwinde"/><tt><b>MWA, MWX, MWY</b></tt> - move word using
accumulator, X or Y</dt>
<dd>These pseudo-commands require two operands
and are combinations of two <tt>MV*</tt>'s:
one to move the low byte, and the other to move the high byte.<br/>
You can't use indirect nor pseudo addressing mode with <tt>MW*</tt>.
Destination must be an absolute address, optionally indexed.<br/>
When source is also an absolute address, an <tt>mw* source dest</tt> expands to:
<pre> mv* source  dest
 mv* source+1 dest+1
</pre>
When source is an immediate value, an <tt>mw* #immed dest</tt> expands to:
<pre> mv* &lt;immed dest
 mv* &gt;immed dest+1
</pre>
When <tt>&lt;immed</tt> equals <tt>&gt;immed</tt> and <tt>immed</tt>
is not forward-referenced, <b>xasm</b> skips the second <tt>LD*</tt>:
<pre> mv* &lt;immed dest
 st* dest+1
</pre>
If possible, <tt>MWX</tt> and <tt>MWY</tt> use increment/decrement
commands. For example, <tt>mwx #1 dest</tt> expands to:
<pre> ldx #1
 stx dest
 dex
 stx dest+1
</pre></dd>
</dl>
<h2>ADDRESSING MODES</h2>
<p>All addressing modes are entered in the standard 6502 convention except for
the accumulator addressing mode, which should be marked with
the <tt>@</tt> character (as in Quick Assembler).</p>
<p>There are two extra immediate addressing modes:
<tt>&lt;</tt> and <tt>&gt;</tt>,
which use the low/high byte of a 16-bit word constant.
They are for Quick Assembler compatibility.
You can use traditional <tt>#&lt;</tt> and <tt>#&gt;</tt>.
Note that <tt>lda &gt;$ff+5</tt> loads 1 (<tt>&gt;$104</tt>),
while <tt>lda #&gt;$ff+5</tt>
loads 5 (<tt>0+5</tt>) to the accumulator, because the unary operator
<tt>&gt;</tt> has a higher priority than the binary plus.</p>
<p>You can explicitly choose absolute (<tt>a:</tt>)
and zero-page (<tt>z:</tt>) addressing modes.</p>
<p>Examples:</p>
<pre>
 nop
 asl @
 lda &gt;$1234  assembles to lda #$12
 lda $100,x
 lda 0       zero-page (8-bit address)
 lda a:0     absolute (16-bit address)
 jmp ($0a)
 lda ($80),y
</pre>
<p>There are pseudo addressing modes, which are similar to
pseudo-commands. You may use them just like standard addressing modes
in all 6502 commands and pseudo-commands, except for
<tt>MWA</tt>, <tt>MWX</tt> and <tt>MWY</tt>:</p>
<pre> cmd a,x+   =  cmd a,x   : inx
 cmd a,x-   =  cmd a,x   : dex
 cmd a,y+   =  cmd a,y   : iny
 cmd a,y-   =  cmd a,y   : dey
 cmd (z),y+ =  cmd (z),y : iny
 cmd (z),y- =  cmd (z),y : dey
 cmd (z,0)  =  ldx #0    : cmd (z,x)
 cmd (z),0  =  ldy #0    : cmd (z),y
<a id="new_adrmodes"/> cmd (z),0+ =  ldy #0    : cmd (z),y : iny
 cmd (z),0- =  ldy #0    : cmd (z),y : dey
</pre>
<h2>HISTORY</h2>
<h3>Version 3.0.1 (2007-04-22)</h3>
<ul>
<li>fixed a bug in <tt>OPT H-</tt> mode</li>
<li>made <b>xasm</b> compilable with the latest D compiler v1.010
(there were incompatible changes in the D language and library)</li>
</ul>
<h3>Version 3.0.0 (2005-05-22)</h3>
<ul>
<li>rewritten from the x86 assembly language to the
<a href="http://www.digitalmars.com/d">D programming language</a>
- Linux version is now available and plain DOS is no longer supported</li>
<li>no limits for the line length, number of <tt>ICL</tt>s, <tt>ORG</tt>s,
<tt>IFT</tt>s and labels</li>
<li>Unix-style command-line options are supported:
<pre>xasm -i -d DEBUG=1 -l listing.lst source.asx
</pre></li>
<li><tt>/e</tt> option is no longer supported</li>
<li>the label table is now sorted alphabetically</li>
</ul>
<h3>Version 2.6.1 (2005-05-21)</h3>
<ul>
<li>no more "Arithmetic overflow" and "Division by zero" errors when correctly
using forward-referenced labels (bug found by Marcin Lewandowski)</li>
<li>the following now assembles:
<pre> ift 0
foo equ 1
 ift foo
 eif
 eif
</pre>
(bug found by Adrian Matoga)</li>
<li>errors for non-existing <tt>INC @</tt> and <tt>DEC @</tt></li>
<li>negative numbers fixed in the listing</li>
</ul>
<h3>Version 2.6.0 (2005-02-07)</h3>
<ul>
<li>long file names are supported under Windows</li>
<li><a href="#new_orgr">support for code that is relocated at runtime</a></li>
<li><a href="#new_linecnt">line repeat counter</a></li>
<li>label values are now 32-bit, not just 17-bit</li>
<li>command-line options <tt>/n</tt> and <tt>/s</tt> are no longer
supported</li>
<li>fatal I/O errors (such as floppy not ready) no longer print the annoying
'<tt>Abort, Retry, Ignore</tt>' message</li>
</ul>
<h3>Version 2.5.2 (2002-10-03)</h3>
<ul>
<li>version 2.5.1 broke Unix EOLs - fixed</li>
<li>version 2.5.1 omitted all blank/comment/label lines, unless <tt>/c</tt>
was used</li>
</ul>
<h3>Version 2.5.1 (2002-08-21)</h3>
<ul>
<li>fixed assembling sources with Atari EOLs</li>
<li>blank/comment/label lines in false conditionals are now correctly omitted
in listing</li>
</ul>
<h3>Version 2.5 (2002-07-08)</h3>
<ul>
<li>fixed another bug, very similar to the previous one, e.g.
<pre> ift 0
:label nop
 eif
</pre>
reported <tt>Label not defined before</tt> error for the repeat count</li>
<li><a href="#new_opt"><tt>OPT F+</tt> causes <tt>ORG</tt>s to fill the space
between the old and the new location with <tt>$FF</tt>s</a></li>
<li><a href="#new_opt"><tt>OPT G+</tt> enables Atari 5200 mode for hardware
register abbreviations</a></li>
</ul>
<h3>Version 2.4.1 (2002-06-27)</h3>
<ul>
<li>fixed a bug related to label definitions in conditionally skipped code,
e.g.
<pre> ift 0
label
 eif
</pre>
reported <tt>No ORG specified</tt> error for the label definition</li>
</ul>
<h3>Version 2.4 (2002-05-22)</h3>
<ul>
<li>fixed a bug causing incorrect unary operator precedence</li>
<li>fixed wrong label value after a skip pseudo-command</li>
<li>the assembler is .EXE (.COM caused problems with DJGPP make due
to a bug in the DJGPP runtime)</li>
<li>the assembler is not compressed (so it occupies less space in the ZIP)</li>
<li>improved command-line parsing: options may be used before source file
name, tab character is a valid separator, <tt>/</tt> may be used as a directory
separator</li>
<li>error and warning messages are written to stderr, not stdout</li>
<li>added <tt>==</tt> (equals) operator, which is equivalent to
<tt>=</tt>(but is more natural for C/C++/Java programmers)</li>
<li><a href="#new_deflabel">added <tt>/d:label=value</tt> option: define
a label</a></li>
<li><a href="#new_fullpaths">added <tt>/p</tt> option: print full paths
in listing and error messages</a></li>
<li><a href="#new_quiet">added <tt>/q</tt> option: quiet mode</a></li>
<li><a href="#new_unlabels">added <tt>/u</tt> option: warn of unused
labels</a></li>
<li><a href="#new_opt">writing to the object file may be suppressed
with <tt>OPT O-</tt></a></li>
<li><a href="#new_eli">added <tt>ELI</tt> (else if) directive</a></li>
<li><a href="#new_mwinde"><tt>MWX</tt> and <tt>MWY</tt> may use
<tt>INX</tt>/<tt>DEX</tt> and <tt>INY</tt>/<tt>DEY</tt>, respectively,
for generating smaller code</a></li>
</ul>
<h3>Version 2.3 (2002-02-10)</h3>
<ul>
<li>double skip (e.g. <tt>SCC:SNE</tt>) bug fixed</li>
<li>real number two-digit exponent bug fixed</li>
<li>trailing spaces in a listing line are now truncated</li>
<li>label definitions allowed in blank, comment and repeated lines</li>
<li><a href="#new_unary">unary operators</a></li>
<li><a href="#new_dta"><tt>DTA</tt> implied byte mode</a></li>
<li><a href="#new_op_op">operand can be skipped for some op-codes</a></li>
</ul>
<h3>Version 2.2 (1999-09-10)</h3>
<ul>
<li>invalid absolute <tt>CPX</tt> and <tt>CPY</tt> op-codes fixed</li>
<li>fixed: addressing mode not checked for branch commands</li>
<li><tt>ICL</tt> in last line bug fixed</li>
<li><tt>OPT H-H+</tt> bug fixed</li>
<li>first <tt>ORG *</tt> bug fixed</li>
<li>origin setting not required until it is used</li>
<li>Unix ($0a), Macintosh ($0d) and Atari ($9b) EOLs allowed in the source</li>
<li>value of 'true' changed to 1</li>
<li>setting environment variables on error option</li>
<li>assembling only if source newer than object option</li>
<li><a href="#new_opcode">op-code extracting</a></li>
<li><a href="#new_linerep">line repeating</a></li>
<li><a href="#new_pairing">instructions pairing</a></li>
<li><a href="#new_repskip">conditional repeat and skip pseudo commands</a></li>
<li><a href="#new_adrmodes"><tt>(),0+</tt> and <tt>(),0-</tt> pseudo
addressing modes</a></li>
</ul>
<h3>Version 2.0 (1998-11-12)</h3>
<ul>
<li>truncating name of object bug fixed</li>
<li><tt>EQU</tt> and <tt>DTA</tt> forward reference bugs fixed</li>
<li>hex number recognizing bug fixed</li>
<li>now <tt>.OBX</tt> is the default extension for Atari executables</li>
<li>assembling options (switches and <tt>OPT</tt> directive)</li>
<li>listing generation</li>
<li>label table generation</li>
<li>conditional assembly</li>
<li>user errors</li>
<li>warnings</li>
<li>improved headers generation</li>
<li>improved expressions - 19 operators and brackets, 32-bit arithmetic</li>
<li>improved signed numbers</li>
<li>6 new pseudo commands (memory-to-memory move)</li>
<li>8 pseudo addressing modes</li>
<li>indirect conditional jumps</li>
<li>Atari floating-point numbers generation</li>
<li>improved <tt>INS</tt>: inserting specified part of file</li>
</ul>
<h3>Version 1.2 (1998-08-14)</h3>
<ul>
<li>first release</li>
</ul>
<h2>AUTHOR</h2>
<p>Piotr Fusik (<a href="mailto:fox@scene.pl">fox@scene.pl</a>)</p>
<h2>SEE ALSO</h2>
<p>xasm home page
(<a href="http://xasm.atari.org">http://xasm.atari.org</a>)</p>
</body>
</html>
